\chapter{绪论}
\label{chap:intro}

传统计算机存储包括内存和外存两层架构。内存采用高性能但具有易失性的随机访问存储器（dynamic random access memory，DRAM），而外存采用非易失性的但性能较弱的块设备，如机械硬盘。
相应地，操作系统设计了虚拟内存和I/O系统\cite{Galvin:2013:OSC:2531466,Tanenbaum:2014:MOS:2655363}来完成对两种形态数据的协调和管理，不可避免地带来诸多性能和管理开销\cite{Lang:1977:DBP:320576.320585,Yu:2014:OBI:2642648.2619092}。

近年来，科研人员开发出一类非易失性内存，融合了传统内存的高性能和随机访问特性，以及传统外存的持久化和非易失特性。典型的非易失性内存介质包括闪存\cite{705361,542301}、自旋扭矩转换内存（spin-torque transfer RAM，STT-RAM）\cite{4443191,6557176}、相变内存（phase-change memory，PCM）\cite{Loke22062012,6176872,Raoux:2008:PRA,10.1109/MM.2010.24}以及电阻式内存（ReRAM）\cite{5607274}等。

非易失性内存有望改变传统的双层存储架构，构成内外存统一的\emph{单层}存储系统。我们将围绕非易失性存储介质的软硬件系统称为\textbf{持久性内存系统}。它使得内存数据在系统故障发生后依然得以保留。单层的持久性内存系统可以减少数据在内存和外存之间的传输、在内存数据结构和外存数据结构之间的转换、相关的系统调用等开销\cite{meza2013case}。

新的持久性内存系统在展现诱人前景的同时，亦面临着诸多技术挑战，诸如非易失性内存硬件的耐久性、纠错等（第\ref{intro:nvm-review}节）。这些问题在硬件层面可以得到较好的解决。然而，\textbf{故障时数据一致性}（crash consistency）问题（第\ref{intro:crash-consistency}节）由于同时涉及软硬件系统且对性能优化的要求高而变得尤为棘手。数据一致性是应用程序对存储系统不可或缺的最基本要求之一，所以该问题成为持久性内存在实际中应用的一个重大障碍\cite{Onur:2014:RPO}。基于此，本论文聚焦于为持久性内存系统支持故障时数据一致性研究高效的软硬件机制和策略。

在数据一致性机制的设计中，面向应用的接口扮演着重要的角色。接口方式和语义决定了持久性内存系统的易用性，也决定了性能和效能优化的空间。在整个软硬件系统栈中，文件系统、事务性内存和对软件透明的硬件接口代表了三类典型的接口方式。\textbf{本论文系统研究了采用文件系统、事务性内存和软件透明三种主要数据存取接口方式下，如何为持久性内存系统设计和实现高效的故障时数据一致性保证机制的问题。}本文主要研究内容和成果包括:

\begin{itemize}
\item 文件系统接口下持久性内存系统的故障时数据一致性机制。设计了\textbf{多版本缓存事务技术}，通过将原子性事务（atomic transaction）机制引入操作系统页缓存，解决由动态内存和非易失性内存构成的持久性内
存系统的故障时数据一致性问题。将该技术应用于移动系统环境，在新的持久性内存系统假设下，改进现有手机文件系统设计，提出优化系统能耗和应用响应的新指标和新策略算法。
\item 事务性内存接口下持久性内存系统的故障时数据一致性机制。根据NVM Express\cite{nvme}接口和固态硬盘的新特性，为事务性内存设计了一种高效的具有一致性保证的持久化机制，为持久性内
存提供了一种新的实现方式。该机制包含\textbf{小缓冲区组}的新技术（small buffer array）。该技术在保证故障时数据一致性的同时，显著降低组提交（group commit）中提交者相互等待的时间，兼得理想的吞吐量和延迟。
\item 对软件透明的持久性内存系统故障时数据一致性机制。提出支持软件透明的故障时数据
一致性的混合持久性内存设计，和\textbf{双模式检查点生成技术}。通过双模式检查点生成技术高效地生成一致的可恢复的检查点。该技术同时在缓存块粒度和页粒度上产生检查点，可使软件执行与产生检查点的延迟重合，大幅减少停滞时间，而仅占用较小的硬件空间。
\item 对软件透明的故障时数据一致性协议及其形式化证明。双模式检查点生成技术，对数据一致性保证提出了新的挑战。多个数据版本的隔离和维护，在程序执行和生成检查点过程重合的情况下变得尤为复杂；与此同时，硬件实现需要简单的逻辑设计。为此我们提出并利用状态机模型表达了故障时数据一致性协议。同时，我们还对代码级实现进行了符号抽象，利用不变式和数学归纳法对故障时数据一致性协议的正确性进行了形式化证明。
\end{itemize}

\section{非易失性内存相关技术回顾}
\label{intro:nvm-review}

部分非易失性内存介质，如PCM，面临耐久性问题。磨损均衡（wear leveling）和比特映射（bit mapping）是解决该问题，扩展非易失性内存介质耐久性的典型技术。在磨损均衡技术中，行移动（row shifting）可以避免一个行内各存储单元上热点区域对存储介质的损害，而段交换（segment swapping）\cite{Qureshi:2009:SHP:1555754.1555760}可以平衡对页的使用\cite{Zhou:2009:DEE:1555754.1555759}。起始间隔（Start-gap）技术\cite{Qureshi:2009:SHP:1555754.1555760}维护从逻辑内存地址到物理内存地址的代数映射关系，而不依靠追踪内存写得到的统计结果。

另一方面，科研人员希望减少冗余的比特粒度的写入。传统存储系统在页或块粒度上向持久性介质写入数据，而这些页或块的内部有相当的比例并没有被更改。对于PCM等非易失性内存，最佳的方式是未修改的比特位可以不写入内存介质。文献\cite{Zhou:2009:DEE:1555754.1555759}利用PCM读性能显著优于写性能的特性，在每次写之前读出原有数据来定位未修改的比特位。Flip-N-Write\cite{5375405}技术给每个PCM上的字附加一位翻转标记，来表明物理的0或1与逻辑的0或1的对应关系。当这个字被修改时，通过计算最小的比特重置的数量来设置该翻转标记位，从而减少比特级的写入量，获得性能、能耗和耐久性等的提升。

错误修复对非易失性内存有着特别的意义，因为与易失性内存不同，非易失性内存保存的数据具有持久性，一旦发生错误代价更为高昂。考虑到PCM相对DRAM而言耐久性弱，错误恢复技术多选择内置在硬件中。动态复制内存技术\cite{Ipek:2010:DRM:1736020.1736023}保存一个页的两个副本，而Zombie\cite{Azevedo:2013:ZME:2485922.2485961}则针对单层存储单元（single-level cell，SLC）和多层存储单元（multi-level cell，MLC）的结构，提出和扩展了多种内存错误修复技术。

\section{持久性内存系统的数据一致性问题}
\label{intro:crash-consistency}

故障时数据一致性是持久性内存系统面临的最为棘手的问题之一\cite{Onur:2014:RPO}。故障时数据一致性的定义是，系统发生故障并恢复后，内存数据呈现为历史上时间点$t$时的快照，即所有$t$之前的内存写按其接收顺序体现在数据存储中而所有$t$之后的内存写都不保存。

数据不一致会给应用程序带来很多严重错误。例如悬空指针（dangling pointer）问题\cite{Volos:2011:MLP:1950365.1950379,Coburn:2011:NMP:1950365.1950380}。假设一个应用在持久性内存中写入了一组特定的数据，并使用一个指针引用这些数据。系统故障恢复后，如果先写入的数据丢失了，而后写入的指针被保留（违背上述时间点$t$的一致性定义），那么程序后续一旦使用该悬空指针就可能引发严重的运行时异常或错误。再比如经典的原子更新问题。假设客户要求从银行账户A中减除部分数额的资金加到银行账户B上。如果标志操作原子性完成的写先于对账户A的写\emph{或}对账户B的写发生，那么一旦系统中途发生故障，回滚的状态违背一致性定义，就可能出现账户A钱少了而账户B未加钱（或者相反）的状况。这显然无法满足程序语义上的要求，可能对各方系统用户造成重大损失。

\section{本文内容及结构}

为了解决持久性内存系统中数据一致性保证的问题，我们从文件系统作为访问接口、事务性内存作为访问接口和对软件透明的三个角度进行了研究，分别对应于第\ref{chap:vct}章、第\ref{chap:sba}章和第\ref{chap:thynvm}章的内容。这三个角度涵盖了持久性内存系统最主要的接口方式。此外，软件透明的一致性协议具有一定复杂度且是相对独立的重要贡献，其定义及证明放置在第\ref{chap:protocol}章。第\ref{chap:conclusion}章总结了本文工作并对未来方向寄予了展望。

